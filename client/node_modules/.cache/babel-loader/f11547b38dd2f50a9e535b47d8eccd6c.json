{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst crypto = require('crypto');\n\nconst http = require('http');\n\nconst url = require('url');\n\nconst PerMessageDeflate = require('./permessage-deflate');\n\nconst extension = require('./extension');\n\nconst constants = require('./constants');\n\nconst WebSocket = require('./websocket');\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\n\n\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {String} options.host The hostname where to bind the server\n   * @param {Number} options.port The port where to bind the server\n   * @param {http.Server} options.server A pre-created HTTP/S server to use\n   * @param {Function} options.verifyClient An hook to reject connections\n   * @param {Function} options.handleProtocols An hook to handle protocols\n   * @param {String} options.path Accept only connections matching this path\n   * @param {Boolean} options.noServer Enable no server mode\n   * @param {Boolean} options.clientTracking Specifies whether or not to track clients\n   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\n   * @param {Number} options.maxPayload The maximum allowed message size\n   * @param {Function} callback A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n    options = Object.assign({\n      maxPayload: 100 * 1024 * 1024,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null,\n      // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null\n    }, options);\n\n    if (options.port == null && !options.server && !options.noServer) {\n      throw new TypeError('One of the \"port\", \"server\", or \"noServer\" options must be specified');\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n\n      this._server.listen(options.port, options.host, options.backlog, callback);\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, ws => {\n            this.emit('connection', ws, req);\n          });\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) this.clients = new Set();\n    this.options = options;\n  }\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n\n\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n  /**\n   * Close the server.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n\n\n  close(cb) {\n    //\n    // Terminate all associated clients.\n    //\n    if (this.clients) {\n      for (const client of this.clients) client.terminate();\n    }\n\n    const server = this._server;\n\n    if (server) {\n      this._removeListeners();\n\n      this._removeListeners = this._server = null; //\n      // Close the http server if it was internally created.\n      //\n\n      if (this.options.port != null) return server.close(cb);\n    }\n\n    if (cb) cb();\n  }\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n\n\n  shouldHandle(req) {\n    if (this.options.path && url.parse(req.url).pathname !== this.options.path) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n\n\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n    const version = +req.headers['sec-websocket-version'];\n    const extensions = {};\n\n    if (req.method !== 'GET' || req.headers.upgrade.toLowerCase() !== 'websocket' || !req.headers['sec-websocket-key'] || version !== 8 && version !== 13 || !this.shouldHandle(req)) {\n      return abortHandshake(socket, 400);\n    }\n\n    if (this.options.perMessageDeflate) {\n      const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);\n\n      try {\n        const offers = extension.parse(req.headers['sec-websocket-extensions']);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        return abortHandshake(socket, 400);\n      }\n    } //\n    // Optionally call external client verification handler.\n    //\n\n\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.connection.authorized || req.connection.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(extensions, req, socket, head, cb);\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(extensions, req, socket, head, cb);\n  }\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @private\n   */\n\n\n  completeUpgrade(extensions, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n    const key = crypto.createHash('sha1').update(req.headers['sec-websocket-key'] + constants.GUID, 'binary').digest('base64');\n    const headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', `Sec-WebSocket-Accept: ${key}`];\n    const ws = new WebSocket(null);\n    var protocol = req.headers['sec-websocket-protocol'];\n\n    if (protocol) {\n      protocol = protocol.split(',').map(trim); //\n      // Optionally call external protocol selection handler.\n      //\n\n      if (this.options.handleProtocols) {\n        protocol = this.options.handleProtocols(protocol, req);\n      } else {\n        protocol = protocol[0];\n      }\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws.protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    } //\n    // Allow external modification/inspection of handshake headers.\n    //\n\n\n    this.emit('headers', headers, req);\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n    ws.setSocket(socket, head, this.options.maxPayload);\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => this.clients.delete(ws));\n    }\n\n    cb(ws);\n  }\n\n}\n\nmodule.exports = WebSocketServer;\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when called\n * @private\n */\n\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n/**\n * Handle premature socket errors.\n *\n * @private\n */\n\n\nfunction socketOnError() {\n  this.destroy();\n}\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {net.Socket} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\n\n\nfunction abortHandshake(socket, code, message, headers) {\n  if (socket.writable) {\n    message = message || http.STATUS_CODES[code];\n    headers = Object.assign({\n      'Connection': 'close',\n      'Content-type': 'text/html',\n      'Content-Length': Buffer.byteLength(message)\n    }, headers);\n    socket.write(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` + Object.keys(headers).map(h => `${h}: ${headers[h]}`).join('\\r\\n') + '\\r\\n\\r\\n' + message);\n  }\n\n  socket.removeListener('error', socketOnError);\n  socket.destroy();\n}\n/**\n * Remove whitespace characters from both ends of a string.\n *\n * @param {String} str The string\n * @return {String} A new string representing `str` stripped of whitespace\n *     characters from both its beginning and end\n * @private\n */\n\n\nfunction trim(str) {\n  return str.trim();\n}","map":{"version":3,"sources":["C:/Users/Saralin/IdeaProjects/fullstack-typescript-mern-todo/client/node_modules/ws/lib/websocket-server.js"],"names":["EventEmitter","require","crypto","http","url","PerMessageDeflate","extension","constants","WebSocket","WebSocketServer","constructor","options","callback","Object","assign","maxPayload","perMessageDeflate","handleProtocols","clientTracking","verifyClient","noServer","backlog","server","host","path","port","TypeError","_server","createServer","req","res","body","STATUS_CODES","writeHead","length","end","listen","_removeListeners","addListeners","listening","emit","bind","error","upgrade","socket","head","handleUpgrade","ws","clients","Set","address","Error","close","cb","client","terminate","shouldHandle","parse","pathname","on","socketOnError","version","headers","extensions","method","toLowerCase","abortHandshake","offers","extensionName","accept","err","info","origin","secure","connection","authorized","encrypted","verified","code","message","completeUpgrade","readable","writable","destroy","key","createHash","update","GUID","digest","protocol","split","map","trim","push","params","value","format","_extensions","write","concat","join","removeListener","setSocket","add","delete","module","exports","event","keys","removeListeners","Buffer","byteLength","h","str"],"mappings":"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","sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst crypto = require('crypto');\nconst http = require('http');\nconst url = require('url');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst extension = require('./extension');\nconst constants = require('./constants');\nconst WebSocket = require('./websocket');\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {String} options.host The hostname where to bind the server\n   * @param {Number} options.port The port where to bind the server\n   * @param {http.Server} options.server A pre-created HTTP/S server to use\n   * @param {Function} options.verifyClient An hook to reject connections\n   * @param {Function} options.handleProtocols An hook to handle protocols\n   * @param {String} options.path Accept only connections matching this path\n   * @param {Boolean} options.noServer Enable no server mode\n   * @param {Boolean} options.clientTracking Specifies whether or not to track clients\n   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\n   * @param {Number} options.maxPayload The maximum allowed message size\n   * @param {Function} callback A listener for the `listening` event\n   */\n  constructor (options, callback) {\n    super();\n\n    options = Object.assign({\n      maxPayload: 100 * 1024 * 1024,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null\n    }, options);\n\n    if (options.port == null && !options.server && !options.noServer) {\n      throw new TypeError(\n        'One of the \"port\", \"server\", or \"noServer\" options must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(options.port, options.host, options.backlog, callback);\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, (ws) => {\n            this.emit('connection', ws, req);\n          });\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) this.clients = new Set();\n    this.options = options;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address () {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Close the server.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n  close (cb) {\n    //\n    // Terminate all associated clients.\n    //\n    if (this.clients) {\n      for (const client of this.clients) client.terminate();\n    }\n\n    const server = this._server;\n\n    if (server) {\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // Close the http server if it was internally created.\n      //\n      if (this.options.port != null) return server.close(cb);\n    }\n\n    if (cb) cb();\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle (req) {\n    if (this.options.path && url.parse(req.url).pathname !== this.options.path) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade (req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const version = +req.headers['sec-websocket-version'];\n    const extensions = {};\n\n    if (\n      req.method !== 'GET' || req.headers.upgrade.toLowerCase() !== 'websocket' ||\n      !req.headers['sec-websocket-key'] || (version !== 8 && version !== 13) ||\n      !this.shouldHandle(req)\n    ) {\n      return abortHandshake(socket, 400);\n    }\n\n    if (this.options.perMessageDeflate) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = extension.parse(\n          req.headers['sec-websocket-extensions']\n        );\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        return abortHandshake(socket, 400);\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.connection.authorized || req.connection.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(extensions, req, socket, head, cb);\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(extensions, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @private\n   */\n  completeUpgrade (extensions, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    const key = crypto.createHash('sha1')\n      .update(req.headers['sec-websocket-key'] + constants.GUID, 'binary')\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${key}`\n    ];\n\n    const ws = new WebSocket(null);\n    var protocol = req.headers['sec-websocket-protocol'];\n\n    if (protocol) {\n      protocol = protocol.split(',').map(trim);\n\n      //\n      // Optionally call external protocol selection handler.\n      //\n      if (this.options.handleProtocols) {\n        protocol = this.options.handleProtocols(protocol, req);\n      } else {\n        protocol = protocol[0];\n      }\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws.protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, this.options.maxPayload);\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => this.clients.delete(ws));\n    }\n\n    cb(ws);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when called\n * @private\n */\nfunction addListeners (server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners () {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Handle premature socket errors.\n *\n * @private\n */\nfunction socketOnError () {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {net.Socket} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake (socket, code, message, headers) {\n  if (socket.writable) {\n    message = message || http.STATUS_CODES[code];\n    headers = Object.assign({\n      'Connection': 'close',\n      'Content-type': 'text/html',\n      'Content-Length': Buffer.byteLength(message)\n    }, headers);\n\n    socket.write(\n      `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n      Object.keys(headers).map(h => `${h}: ${headers[h]}`).join('\\r\\n') +\n      '\\r\\n\\r\\n' +\n      message\n    );\n  }\n\n  socket.removeListener('error', socketOnError);\n  socket.destroy();\n}\n\n/**\n * Remove whitespace characters from both ends of a string.\n *\n * @param {String} str The string\n * @return {String} A new string representing `str` stripped of whitespace\n *     characters from both its beginning and end\n * @private\n */\nfunction trim(str) {\n  return str.trim();\n}\n"]},"metadata":{},"sourceType":"script"}