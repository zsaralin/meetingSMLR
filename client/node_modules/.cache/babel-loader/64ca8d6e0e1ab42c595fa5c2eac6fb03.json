{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst crypto = require('crypto');\n\nconst https = require('https');\n\nconst http = require('http');\n\nconst net = require('net');\n\nconst tls = require('tls');\n\nconst url = require('url');\n\nconst PerMessageDeflate = require('./permessage-deflate');\n\nconst EventTarget = require('./event-target');\n\nconst extension = require('./extension');\n\nconst constants = require('./constants');\n\nconst Receiver = require('./receiver');\n\nconst Sender = require('./sender');\n\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst kWebSocket = constants.kWebSocket;\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000; // Allow 30 seconds to terminate the connection cleanly.\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\n\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|url.Url|url.URL)} address The URL to which to connect\n   * @param {(String|String[])} protocols The subprotocols\n   * @param {Object} options Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n    this.readyState = WebSocket.CONNECTING;\n    this.protocol = '';\n    this._binaryType = constants.BINARY_TYPES[0];\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = '';\n    this._closeTimer = null;\n    this._closeCode = 1006;\n    this._extensions = {};\n    this._isServer = true;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      if (Array.isArray(protocols)) {\n        protocols = protocols.join(', ');\n      } else if (typeof protocols === 'object' && protocols !== null) {\n        options = protocols;\n        protocols = undefined;\n      }\n\n      initAsClient.call(this, address, protocols, options);\n    }\n  }\n\n  get CONNECTING() {\n    return WebSocket.CONNECTING;\n  }\n\n  get CLOSING() {\n    return WebSocket.CLOSING;\n  }\n\n  get CLOSED() {\n    return WebSocket.CLOSED;\n  }\n\n  get OPEN() {\n    return WebSocket.OPEN;\n  }\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the required\n   * default \"blob\" type (instead we define a custom \"nodebuffer\" type).\n   *\n   * @type {String}\n   */\n\n\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (constants.BINARY_TYPES.indexOf(type) < 0) return;\n    this._binaryType = type; //\n    // Allow to change `binaryType` on the fly.\n    //\n\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n  /**\n   * @type {Number}\n   */\n\n\n  get bufferedAmount() {\n    if (!this._socket) return 0; //\n    // `socket.bufferSize` is `undefined` if the socket is closed.\n    //\n\n    return (this._socket.bufferSize || 0) + this._sender._bufferedBytes;\n  }\n  /**\n   * @type {String}\n   */\n\n\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Number} maxPayload The maximum allowed message size\n   * @private\n   */\n\n\n  setSocket(socket, head, maxPayload) {\n    const receiver = new Receiver(this._binaryType, this._extensions, maxPayload);\n    this._sender = new Sender(socket, this._extensions);\n    this._receiver = receiver;\n    this._socket = socket;\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n    socket.setTimeout(0);\n    socket.setNoDelay();\n    if (head.length > 0) socket.unshift(head);\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n    this.readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n\n\n  emitClose() {\n    this.readyState = WebSocket.CLOSED;\n\n    if (!this._socket) {\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} code Status code explaining why the connection is closing\n   * @param {String} data A string explaining why the connection is closing\n   * @public\n   */\n\n\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();\n      return;\n    }\n\n    this.readyState = WebSocket.CLOSING;\n\n    this._sender.close(code, data, !this._isServer, err => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n      this._closeFrameSent = true;\n\n      if (this._socket.writable) {\n        if (this._closeFrameReceived) this._socket.end(); //\n        // Ensure that the connection is closed even if the closing handshake\n        // fails.\n        //\n\n        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);\n      }\n    });\n  }\n  /**\n   * Send a ping.\n   *\n   * @param {*} data The data to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when the ping is sent\n   * @public\n   */\n\n\n  ping(data, mask, cb) {\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (this.readyState !== WebSocket.OPEN) {\n      const err = new Error(`WebSocket is not open: readyState ${this.readyState} ` + `(${readyStates[this.readyState]})`);\n      if (cb) return cb(err);\n      throw err;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n    if (mask === undefined) mask = !this._isServer;\n\n    this._sender.ping(data || constants.EMPTY_BUFFER, mask, cb);\n  }\n  /**\n   * Send a pong.\n   *\n   * @param {*} data The data to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when the pong is sent\n   * @public\n   */\n\n\n  pong(data, mask, cb) {\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (this.readyState !== WebSocket.OPEN) {\n      const err = new Error(`WebSocket is not open: readyState ${this.readyState} ` + `(${readyStates[this.readyState]})`);\n      if (cb) return cb(err);\n      throw err;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n    if (mask === undefined) mask = !this._isServer;\n\n    this._sender.pong(data || constants.EMPTY_BUFFER, mask, cb);\n  }\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when data is written out\n   * @public\n   */\n\n\n  send(data, options, cb) {\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (this.readyState !== WebSocket.OPEN) {\n      const err = new Error(`WebSocket is not open: readyState ${this.readyState} ` + `(${readyStates[this.readyState]})`);\n      if (cb) return cb(err);\n      throw err;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n    const opts = Object.assign({\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true\n    }, options);\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || constants.EMPTY_BUFFER, opts, cb);\n  }\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n\n\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this._socket) {\n      this.readyState = WebSocket.CLOSING;\n\n      this._socket.destroy();\n    }\n  }\n\n}\n\nreadyStates.forEach((readyState, i) => {\n  WebSocket[readyStates[i]] = i;\n}); //\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n\n['open', 'error', 'close', 'message'].forEach(method => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    /**\n     * Return the listener of the event.\n     *\n     * @return {(Function|undefined)} The event listener or `undefined`\n     * @public\n     */\n    get() {\n      const listeners = this.listeners(method);\n\n      for (var i = 0; i < listeners.length; i++) {\n        if (listeners[i]._listener) return listeners[i]._listener;\n      }\n    },\n\n    /**\n     * Add a listener for the event.\n     *\n     * @param {Function} listener The listener to add\n     * @public\n     */\n    set(listener) {\n      const listeners = this.listeners(method);\n\n      for (var i = 0; i < listeners.length; i++) {\n        //\n        // Remove only the listeners added via `addEventListener`.\n        //\n        if (listeners[i]._listener) this.removeListener(method, listeners[i]);\n      }\n\n      this.addEventListener(method, listener);\n    }\n\n  });\n});\nWebSocket.prototype.addEventListener = EventTarget.addEventListener;\nWebSocket.prototype.removeEventListener = EventTarget.removeEventListener;\nmodule.exports = WebSocket;\n/**\n * Initialize a WebSocket client.\n *\n * @param {(String|url.Url|url.URL)} address The URL to which to connect\n * @param {String} protocols The subprotocols\n * @param {Object} options Connection options\n * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\n * @param {Number} options.handshakeTimeout Timeout in milliseconds for the handshake request\n * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version` header\n * @param {String} options.origin Value of the `Origin` or `Sec-WebSocket-Origin` header\n * @private\n */\n\nfunction initAsClient(address, protocols, options) {\n  options = Object.assign({\n    protocolVersion: protocolVersions[1],\n    perMessageDeflate: true\n  }, options, {\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: undefined,\n    auth: undefined,\n    host: undefined,\n    path: undefined,\n    port: undefined\n  });\n\n  if (protocolVersions.indexOf(options.protocolVersion) === -1) {\n    throw new RangeError(`Unsupported protocol version: ${options.protocolVersion} ` + `(supported versions: ${protocolVersions.join(', ')})`);\n  }\n\n  this._isServer = false;\n  var parsedUrl;\n\n  if (typeof address === 'object' && address.href !== undefined) {\n    parsedUrl = address;\n    this.url = address.href;\n  } else {\n    parsedUrl = url.parse(address);\n    this.url = address;\n  }\n\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n\n  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {\n    throw new Error(`Invalid URL: ${this.url}`);\n  }\n\n  const isSecure = parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';\n  const key = crypto.randomBytes(16).toString('base64');\n  const httpObj = isSecure ? https : http;\n  const path = parsedUrl.search ? `${parsedUrl.pathname || '/'}${parsedUrl.search}` : parsedUrl.pathname || '/';\n  var perMessageDeflate;\n  options.createConnection = isSecure ? tlsConnect : netConnect;\n  options.port = parsedUrl.port || (isSecure ? 443 : 80);\n  options.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n  options.headers = Object.assign({\n    'Sec-WebSocket-Version': options.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    'Connection': 'Upgrade',\n    'Upgrade': 'websocket'\n  }, options.headers);\n  options.path = path;\n\n  if (options.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(options.perMessageDeflate !== true ? options.perMessageDeflate : {}, false);\n    options.headers['Sec-WebSocket-Extensions'] = extension.format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n\n  if (protocols) {\n    options.headers['Sec-WebSocket-Protocol'] = protocols;\n  }\n\n  if (options.origin) {\n    if (options.protocolVersion < 13) {\n      options.headers['Sec-WebSocket-Origin'] = options.origin;\n    } else {\n      options.headers.Origin = options.origin;\n    }\n  }\n\n  if (parsedUrl.auth) {\n    options.auth = parsedUrl.auth;\n  } else if (parsedUrl.username || parsedUrl.password) {\n    options.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isUnixSocket) {\n    const parts = path.split(':');\n\n    if (options.agent == null && process.versions.modules < 57) {\n      //\n      // Setting `socketPath` in conjunction with `createConnection` without an\n      // agent throws an error on Node.js < 8. Work around the issue by using a\n      // different property.\n      //\n      options._socketPath = parts[0];\n    } else {\n      options.socketPath = parts[0];\n    }\n\n    options.path = parts[1];\n  }\n\n  var req = this._req = httpObj.get(options);\n\n  if (options.handshakeTimeout) {\n    req.setTimeout(options.handshakeTimeout, () => abortHandshake(this, req, 'Opening handshake has timed out'));\n  }\n\n  req.on('error', err => {\n    if (this._req.aborted) return;\n    req = this._req = null;\n    this.readyState = WebSocket.CLOSING;\n    this.emit('error', err);\n    this.emitClose();\n  });\n  req.on('response', res => {\n    if (this.emit('unexpected-response', req, res)) return;\n    abortHandshake(this, req, `Unexpected server response: ${res.statusCode}`);\n  });\n  req.on('upgrade', (res, socket, head) => {\n    this.emit('upgrade', res); //\n    // The user may have closed the connection from a listener of the `upgrade`\n    // event.\n    //\n\n    if (this.readyState !== WebSocket.CONNECTING) return;\n    req = this._req = null;\n    const digest = crypto.createHash('sha1').update(key + constants.GUID, 'binary').digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(this, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    const protList = (protocols || '').split(/, */);\n    var protError;\n\n    if (!protocols && serverProt) {\n      protError = 'Server sent a subprotocol but none was requested';\n    } else if (protocols && !serverProt) {\n      protError = 'Server sent no subprotocol';\n    } else if (serverProt && protList.indexOf(serverProt) === -1) {\n      protError = 'Server sent an invalid subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(this, socket, protError);\n      return;\n    }\n\n    if (serverProt) this.protocol = serverProt;\n\n    if (perMessageDeflate) {\n      try {\n        const extensions = extension.parse(res.headers['sec-websocket-extensions']);\n\n        if (extensions[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n          this._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        abortHandshake(this, socket, 'Invalid Sec-WebSocket-Extensions header');\n        return;\n      }\n    }\n\n    this.setSocket(socket, head, 0);\n  });\n}\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\n\n\nfunction netConnect(options) {\n  options.path = options.socketPath || options._socketPath || undefined;\n  return net.connect(options);\n}\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\n\n\nfunction tlsConnect(options) {\n  options.path = options.socketPath || options._socketPath || undefined;\n  options.servername = options.servername || options.host;\n  return tls.connect(options);\n}\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the\n *     socket to destroy\n * @param {String} message The error message\n * @private\n */\n\n\nfunction abortHandshake(websocket, stream, message) {\n  websocket.readyState = WebSocket.CLOSING;\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream.abort();\n    stream.once('abort', websocket.emitClose.bind(websocket));\n    websocket.emit('error', err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {String} reason The reason for closing\n * @private\n */\n\n\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._socket.removeListener('data', socketOnData);\n\n  websocket._socket.resume();\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n  if (code === 1005) websocket.close();else websocket.close(code, reason);\n}\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\n\n\nfunction receiverOnDrain() {\n  this[kWebSocket]._socket.resume();\n}\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\n\n\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  websocket._socket.removeListener('data', socketOnData);\n\n  websocket.readyState = WebSocket.CLOSING;\n  websocket._closeCode = err[constants.kStatusCode];\n  websocket.emit('error', err);\n\n  websocket._socket.destroy();\n}\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\n\n\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message\n * @private\n */\n\n\nfunction receiverOnMessage(data) {\n  this[kWebSocket].emit('message', data);\n}\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\n\n\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n  websocket.pong(data, !websocket._isServer, constants.NOOP);\n  websocket.emit('ping', data);\n}\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\n\n\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\n\n\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n  this.removeListener('close', socketOnClose);\n  this.removeListener('end', socketOnEnd);\n  websocket.readyState = WebSocket.CLOSING; //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk and emitted synchronously in a single\n  // `'data'` event.\n  //\n\n  websocket._socket.read();\n\n  websocket._receiver.end();\n\n  this.removeListener('data', socketOnData);\n  this[kWebSocket] = undefined;\n  clearTimeout(websocket._closeTimer);\n\n  if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\n\n\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\n\n\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n  websocket.readyState = WebSocket.CLOSING;\n\n  websocket._receiver.end();\n\n  this.end();\n}\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\n\n\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n  this.removeListener('error', socketOnError);\n  this.on('error', constants.NOOP);\n\n  if (websocket) {\n    websocket.readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}","map":{"version":3,"sources":["C:/Users/Saralin/IdeaProjects/fullstack-typescript-mern-todo/client/node_modules/ws/lib/websocket.js"],"names":["EventEmitter","require","crypto","https","http","net","tls","url","PerMessageDeflate","EventTarget","extension","constants","Receiver","Sender","readyStates","kWebSocket","protocolVersions","closeTimeout","WebSocket","constructor","address","protocols","options","readyState","CONNECTING","protocol","_binaryType","BINARY_TYPES","_closeFrameReceived","_closeFrameSent","_closeMessage","_closeTimer","_closeCode","_extensions","_isServer","_receiver","_sender","_socket","Array","isArray","join","undefined","initAsClient","call","CLOSING","CLOSED","OPEN","binaryType","type","indexOf","bufferedAmount","bufferSize","_bufferedBytes","extensions","Object","keys","setSocket","socket","head","maxPayload","receiver","on","receiverOnConclude","receiverOnDrain","receiverOnError","receiverOnMessage","receiverOnPing","receiverOnPong","setTimeout","setNoDelay","length","unshift","socketOnClose","socketOnData","socketOnEnd","socketOnError","emit","emitClose","extensionName","cleanup","removeAllListeners","close","code","data","msg","abortHandshake","_req","end","err","writable","destroy","bind","ping","mask","cb","Error","toString","EMPTY_BUFFER","pong","send","opts","assign","binary","compress","fin","terminate","forEach","i","method","defineProperty","prototype","get","listeners","_listener","set","listener","removeListener","addEventListener","removeEventListener","module","exports","protocolVersion","perMessageDeflate","createConnection","socketPath","hostname","timeout","auth","host","path","port","RangeError","parsedUrl","href","parse","isUnixSocket","pathname","isSecure","key","randomBytes","httpObj","search","tlsConnect","netConnect","startsWith","slice","headers","format","offer","origin","Origin","username","password","parts","split","agent","process","versions","modules","_socketPath","req","handshakeTimeout","aborted","res","statusCode","digest","createHash","update","GUID","serverProt","protList","protError","accept","connect","servername","websocket","stream","message","captureStackTrace","setHeader","abort","once","reason","resume","kStatusCode","receiverOnFinish","NOOP","read","clearTimeout","_writableState","finished","errorEmitted","chunk","write","pause"],"mappings":"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","sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst crypto = require('crypto');\nconst https = require('https');\nconst http = require('http');\nconst net = require('net');\nconst tls = require('tls');\nconst url = require('url');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst EventTarget = require('./event-target');\nconst extension = require('./extension');\nconst constants = require('./constants');\nconst Receiver = require('./receiver');\nconst Sender = require('./sender');\n\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst kWebSocket = constants.kWebSocket;\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000; // Allow 30 seconds to terminate the connection cleanly.\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|url.Url|url.URL)} address The URL to which to connect\n   * @param {(String|String[])} protocols The subprotocols\n   * @param {Object} options Connection options\n   */\n  constructor (address, protocols, options) {\n    super();\n\n    this.readyState = WebSocket.CONNECTING;\n    this.protocol = '';\n\n    this._binaryType = constants.BINARY_TYPES[0];\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = '';\n    this._closeTimer = null;\n    this._closeCode = 1006;\n    this._extensions = {};\n    this._isServer = true;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      if (Array.isArray(protocols)) {\n        protocols = protocols.join(', ');\n      } else if (typeof protocols === 'object' && protocols !== null) {\n        options = protocols;\n        protocols = undefined;\n      }\n\n      initAsClient.call(this, address, protocols, options);\n    }\n  }\n\n  get CONNECTING () { return WebSocket.CONNECTING; }\n  get CLOSING () { return WebSocket.CLOSING; }\n  get CLOSED () { return WebSocket.CLOSED; }\n  get OPEN () { return WebSocket.OPEN; }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the required\n   * default \"blob\" type (instead we define a custom \"nodebuffer\" type).\n   *\n   * @type {String}\n   */\n  get binaryType () {\n    return this._binaryType;\n  }\n\n  set binaryType (type) {\n    if (constants.BINARY_TYPES.indexOf(type) < 0) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount () {\n    if (!this._socket) return 0;\n\n    //\n    // `socket.bufferSize` is `undefined` if the socket is closed.\n    //\n    return (this._socket.bufferSize || 0) + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions () {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Number} maxPayload The maximum allowed message size\n   * @private\n   */\n  setSocket (socket, head, maxPayload) {\n    const receiver = new Receiver(\n      this._binaryType,\n      this._extensions,\n      maxPayload\n    );\n\n    this._sender = new Sender(socket, this._extensions);\n    this._receiver = receiver;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    socket.setTimeout(0);\n    socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this.readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose () {\n    this.readyState = WebSocket.CLOSED;\n\n    if (!this._socket) {\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} code Status code explaining why the connection is closing\n   * @param {String} data A string explaining why the connection is closing\n   * @public\n   */\n  close (code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();\n      return;\n    }\n\n    this.readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (this._socket.writable) {\n        if (this._closeFrameReceived) this._socket.end();\n\n        //\n        // Ensure that the connection is closed even if the closing handshake\n        // fails.\n        //\n        this._closeTimer = setTimeout(\n          this._socket.destroy.bind(this._socket),\n          closeTimeout\n        );\n      }\n    });\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} data The data to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when the ping is sent\n   * @public\n   */\n  ping (data, mask, cb) {\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (this.readyState !== WebSocket.OPEN) {\n      const err = new Error(\n        `WebSocket is not open: readyState ${this.readyState} ` +\n          `(${readyStates[this.readyState]})`\n      );\n\n      if (cb) return cb(err);\n      throw err;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || constants.EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} data The data to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when the pong is sent\n   * @public\n   */\n  pong (data, mask, cb) {\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (this.readyState !== WebSocket.OPEN) {\n      const err = new Error(\n        `WebSocket is not open: readyState ${this.readyState} ` +\n          `(${readyStates[this.readyState]})`\n      );\n\n      if (cb) return cb(err);\n      throw err;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || constants.EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when data is written out\n   * @public\n   */\n  send (data, options, cb) {\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (this.readyState !== WebSocket.OPEN) {\n      const err = new Error(\n        `WebSocket is not open: readyState ${this.readyState} ` +\n          `(${readyStates[this.readyState]})`\n      );\n\n      if (cb) return cb(err);\n      throw err;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    const opts = Object.assign({\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true\n    }, options);\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || constants.EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate () {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this._socket) {\n      this.readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\nreadyStates.forEach((readyState, i) => {\n  WebSocket[readyStates[i]] = i;\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    /**\n     * Return the listener of the event.\n     *\n     * @return {(Function|undefined)} The event listener or `undefined`\n     * @public\n     */\n    get () {\n      const listeners = this.listeners(method);\n      for (var i = 0; i < listeners.length; i++) {\n        if (listeners[i]._listener) return listeners[i]._listener;\n      }\n    },\n    /**\n     * Add a listener for the event.\n     *\n     * @param {Function} listener The listener to add\n     * @public\n     */\n    set (listener) {\n      const listeners = this.listeners(method);\n      for (var i = 0; i < listeners.length; i++) {\n        //\n        // Remove only the listeners added via `addEventListener`.\n        //\n        if (listeners[i]._listener) this.removeListener(method, listeners[i]);\n      }\n      this.addEventListener(method, listener);\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = EventTarget.addEventListener;\nWebSocket.prototype.removeEventListener = EventTarget.removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {(String|url.Url|url.URL)} address The URL to which to connect\n * @param {String} protocols The subprotocols\n * @param {Object} options Connection options\n * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\n * @param {Number} options.handshakeTimeout Timeout in milliseconds for the handshake request\n * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version` header\n * @param {String} options.origin Value of the `Origin` or `Sec-WebSocket-Origin` header\n * @private\n */\nfunction initAsClient (address, protocols, options) {\n  options = Object.assign({\n    protocolVersion: protocolVersions[1],\n    perMessageDeflate: true\n  }, options, {\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: undefined,\n    auth: undefined,\n    host: undefined,\n    path: undefined,\n    port: undefined\n  });\n\n  if (protocolVersions.indexOf(options.protocolVersion) === -1) {\n    throw new RangeError(\n      `Unsupported protocol version: ${options.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  this._isServer = false;\n\n  var parsedUrl;\n\n  if (typeof address === 'object' && address.href !== undefined) {\n    parsedUrl = address;\n    this.url = address.href;\n  } else {\n    parsedUrl = url.parse(address);\n    this.url = address;\n  }\n\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n\n  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {\n    throw new Error(`Invalid URL: ${this.url}`);\n  }\n\n  const isSecure = parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';\n  const key = crypto.randomBytes(16).toString('base64');\n  const httpObj = isSecure ? https : http;\n  const path = parsedUrl.search\n    ? `${parsedUrl.pathname || '/'}${parsedUrl.search}`\n    : parsedUrl.pathname || '/';\n  var perMessageDeflate;\n\n  options.createConnection = isSecure ? tlsConnect : netConnect;\n  options.port = parsedUrl.port || (isSecure ? 443 : 80);\n  options.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  options.headers = Object.assign({\n    'Sec-WebSocket-Version': options.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    'Connection': 'Upgrade',\n    'Upgrade': 'websocket'\n  }, options.headers);\n  options.path = path;\n\n  if (options.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      options.perMessageDeflate !== true ? options.perMessageDeflate : {},\n      false\n    );\n    options.headers['Sec-WebSocket-Extensions'] = extension.format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols) {\n    options.headers['Sec-WebSocket-Protocol'] = protocols;\n  }\n  if (options.origin) {\n    if (options.protocolVersion < 13) {\n      options.headers['Sec-WebSocket-Origin'] = options.origin;\n    } else {\n      options.headers.Origin = options.origin;\n    }\n  }\n  if (parsedUrl.auth) {\n    options.auth = parsedUrl.auth;\n  } else if (parsedUrl.username || parsedUrl.password) {\n    options.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isUnixSocket) {\n    const parts = path.split(':');\n\n    if (options.agent == null && process.versions.modules < 57) {\n      //\n      // Setting `socketPath` in conjunction with `createConnection` without an\n      // agent throws an error on Node.js < 8. Work around the issue by using a\n      // different property.\n      //\n      options._socketPath = parts[0];\n    } else {\n      options.socketPath = parts[0];\n    }\n\n    options.path = parts[1];\n  }\n\n  var req = this._req = httpObj.get(options);\n\n  if (options.handshakeTimeout) {\n    req.setTimeout(\n      options.handshakeTimeout,\n      () => abortHandshake(this, req, 'Opening handshake has timed out')\n    );\n  }\n\n  req.on('error', (err) => {\n    if (this._req.aborted) return;\n\n    req = this._req = null;\n    this.readyState = WebSocket.CLOSING;\n    this.emit('error', err);\n    this.emitClose();\n  });\n\n  req.on('response', (res) => {\n    if (this.emit('unexpected-response', req, res)) return;\n\n    abortHandshake(this, req, `Unexpected server response: ${res.statusCode}`);\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    this.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the `upgrade`\n    // event.\n    //\n    if (this.readyState !== WebSocket.CONNECTING) return;\n\n    req = this._req = null;\n\n    const digest = crypto.createHash('sha1')\n      .update(key + constants.GUID, 'binary')\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(this, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    const protList = (protocols || '').split(/, */);\n    var protError;\n\n    if (!protocols && serverProt) {\n      protError = 'Server sent a subprotocol but none was requested';\n    } else if (protocols && !serverProt) {\n      protError = 'Server sent no subprotocol';\n    } else if (serverProt && protList.indexOf(serverProt) === -1) {\n      protError = 'Server sent an invalid subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(this, socket, protError);\n      return;\n    }\n\n    if (serverProt) this.protocol = serverProt;\n\n    if (perMessageDeflate) {\n      try {\n        const extensions = extension.parse(\n          res.headers['sec-websocket-extensions']\n        );\n\n        if (extensions[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(\n            extensions[PerMessageDeflate.extensionName]\n          );\n          this._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        abortHandshake(this, socket, 'Invalid Sec-WebSocket-Extensions header');\n        return;\n      }\n    }\n\n    this.setSocket(socket, head, 0);\n  });\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect (options) {\n  options.path = options.socketPath || options._socketPath || undefined;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect (options) {\n  options.path = options.socketPath || options._socketPath || undefined;\n  options.servername = options.servername || options.host;\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the\n *     socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake (websocket, stream, message) {\n  websocket.readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream.abort();\n    stream.once('abort', websocket.emitClose.bind(websocket));\n    websocket.emit('error', err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {String} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude (code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._socket.removeListener('data', socketOnData);\n  websocket._socket.resume();\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain () {\n  this[kWebSocket]._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError (err) {\n  const websocket = this[kWebSocket];\n\n  websocket._socket.removeListener('data', socketOnData);\n\n  websocket.readyState = WebSocket.CLOSING;\n  websocket._closeCode = err[constants.kStatusCode];\n  websocket.emit('error', err);\n  websocket._socket.destroy();\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish () {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message\n * @private\n */\nfunction receiverOnMessage (data) {\n  this[kWebSocket].emit('message', data);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing (data) {\n  const websocket = this[kWebSocket];\n\n  websocket.pong(data, !websocket._isServer, constants.NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong (data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\nfunction socketOnClose () {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('end', socketOnEnd);\n\n  websocket.readyState = WebSocket.CLOSING;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk and emitted synchronously in a single\n  // `'data'` event.\n  //\n  websocket._socket.read();\n  websocket._receiver.end();\n\n  this.removeListener('data', socketOnData);\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData (chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd () {\n  const websocket = this[kWebSocket];\n\n  websocket.readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\nfunction socketOnError () {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', constants.NOOP);\n\n  if (websocket) {\n    websocket.readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}